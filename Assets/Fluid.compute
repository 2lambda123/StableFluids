#pragma kernel Advect
#pragma kernel Force
#pragma kernel PSetup
#pragma kernel PFinish
#pragma kernel Jacobi1
#pragma kernel Jacobi2
#pragma kernel Color

// Common parameter
float Time;
float DeltaTime;

// U (velocity field)
Texture2D<float2> U_in;
SamplerState samplerU_in;
RWTexture2D<float2> U_out;

// W (velocity field; working)
Texture2D<float2> W_in;
RWTexture2D<float2> W_out;

// Div W
RWTexture2D<float> DivW_out;

// P (pressure field)
Texture2D<float> P_in;
RWTexture2D<float> P_out;

// Color map
Texture2D<half4> C_in;
SamplerState samplerC_in;
RWTexture2D<half4> C_out;

// Jacobi method arguments
float Alpha, Beta;

Texture2D<float> X1_in;
Texture2D<float> B1_in;
RWTexture2D<float> X1_out;

Texture2D<float2> X2_in;
Texture2D<float2> B2_in;
RWTexture2D<float2> X2_out;

[numthreads(8, 8, 1)]
void Advect(uint2 tid : SV_DispatchThreadID)
{
    uint Nx, Ny;
    U_in.GetDimensions(Nx, Ny);

    float2 uv = (tid + 0.5) / float2(Nx, Ny) - U_in[tid] * DeltaTime;
    W_out[tid] = U_in.SampleLevel(samplerU_in, uv, 0);
}

[numthreads(8, 8, 1)]
void Force(uint2 tid : SV_DispatchThreadID)
{
    uint columns, rows;
    W_out.GetDimensions(columns, rows);

    float2 p = (float2)tid / float2(columns, rows);
    float2 o = 0.5 + float2(sin(Time * 3.13), sin(Time * 1.32)) * 0.3;

    float d = distance(o, p);
    W_out[tid] += (p - o) / max(d, 1e-5) / exp(300 * d) * 10;
}

[numthreads(8, 8, 1)]
void PSetup(uint2 tid : SV_DispatchThreadID)
{
    uint Nx, Ny;
    W_in.GetDimensions(Nx, Ny);

    DivW_out[tid] = (W_in[tid + int2(1, 0)].x - W_in[tid - int2(1, 0)].x) * Nx / 2 +
                    (W_in[tid + int2(0, 1)].y - W_in[tid - int2(0, 1)].y) * Ny / 2;

    P_out[tid] = 0;
}

[numthreads(8, 8, 1)]
void PFinish(int2 tid : SV_DispatchThreadID)
{
    int Nx, Ny;
    W_in.GetDimensions(Nx, Ny);

    if (any(tid == 0) || any(tid == int2(Nx - 1, Ny - 1))) return;

    float P1 = P_in[max(tid - int2(1, 0), 1)];
    float P2 = P_in[min(tid + int2(1, 0), int2(Nx - 2, Ny - 2))];
    float P3 = P_in[max(tid - int2(0, 1), 1)];
    float P4 = P_in[min(tid + int2(0, 1), int2(Nx - 2, Ny - 2))];

    U_out[tid] = W_in[tid] - float2(P2 - P1, P4 - P3) * Nx / 2;

    if (tid.x == 1) U_out[int2(0, tid.y)] = -U_out[tid];
    if (tid.y == 1) U_out[int2(tid.x, 0)] = -U_out[tid];
    if (tid.x == Nx - 1) U_out[int2(Nx - 1, tid.y)] = -U_out[tid];
    if (tid.y == Ny - 1) U_out[int2(tid.x, Ny - 1)] = -U_out[tid];
}

[numthreads(8, 8, 1)]
void Jacobi1(uint2 tid : SV_DispatchThreadID)
{
    X1_out[tid] = (X1_in[tid - int2(1, 0)] + X1_in[tid + int2(1, 0)] +
                   X1_in[tid - int2(0, 1)] + X1_in[tid + int2(0, 1)] + Alpha * B1_in[tid]) / Beta;
}

[numthreads(8, 8, 1)]
void Jacobi2(uint2 tid : SV_DispatchThreadID)
{
    X2_out[tid] = (X2_in[tid - int2(1, 0)] + X2_in[tid + int2(1, 0)] +
                   X2_in[tid - int2(0, 1)] + X2_in[tid + int2(0, 1)] + Alpha * B2_in[tid]) / Beta;
}

[numthreads(8, 8, 1)]
void Color(uint2 tid : SV_DispatchThreadID)
{
    uint Nx, Ny;
    U_in.GetDimensions(Nx, Ny);

    float2 uv = (tid + 0.5) / float2(Nx, Ny) - U_in[tid] * DeltaTime;
    C_out[tid] = C_in.SampleLevel(samplerC_in, uv, 0);
}
